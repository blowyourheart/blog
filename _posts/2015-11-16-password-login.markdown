---
layout: post
title:  "登录服务加解密"
date:   2015-11-16 20:07:41 +0800
categories: 
---
现在的登录服务一般会将用户的密码加盐，以避免存储密码的明文，而且即使密文泄露了，也很难知道用户的原始密码是多少，这样也不能冒充用户来登录。

发送登录请求时会将(用户名,加密密码）发送过来，然后服务端解密拿到明文密码，并根据用户的用户名拿到数据库中存储的slat和混淆后的密码，按照原来的混淆计算以后比较两个字符串是否相等就能判断是否可以登录了。

这里有一个漏洞，在于如果这个发送登录的请求被监听了，那么监听者也可以冒充这个用户进行登录。要避免被监听登录，就必须在发送加密密钥时只能使用一次，过期作废。可以在发送登录请求时指定一个本次请求的过期时间戳，并把这个时间戳连同原始密码一同加密发送过去，服务端除了判断是否超过过期时间以外，还要判断解密以后的时间戳是否与请求的时间戳一致，防止被篡改。如果服务是通过HTTPS来做的话，就不需要这样做了，HTTPS层完成了加密处理。

另一个问题是防止暴力破解密码，就是对登录请求，对同一个帐号和IP对，不允许频繁访问，比如1分钟只允许访问10次等。通常登录服务是多个实例存在，如果将登录信息存储在服务的内存里，则达不到精确的全局限制作用。

可以基于redis做一个简单的防暴力破解实现。对于每一个帐号和IP对，在redis中用有序集合存储每次访问的时间，每次请求时先查询最近一分钟内登录记录的个数，如果超过10个，则不允许访问，并删除一分钟之前的登录记录。如果没有超过（无记录代表没有超过）, 则将当前记录写入到列表中，删除一分钟之前的记录，并设置当前集合为一分钟的过期时间，并继续后面的操作。

虽然这里会出现同步竞争的情况，但是对于防止暴力破解而言，并不需要很严格的检测性，只需要能防住暴力检测就可以了。

# OAuth 2.0 授权登录 
现在有很多通过其他网站的帐号来登录自己app的服务，比如QQ号，微信号，微博，人人号登录本app，这里用的都是OAuth2.0 开放授权接口来实现的，该协议的具体流程是相当复杂的，不过大部分公司都提供了SDK来协助快速开发。
